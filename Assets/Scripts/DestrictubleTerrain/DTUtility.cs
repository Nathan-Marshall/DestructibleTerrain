/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

using DestructibleTerrain;
using DestructibleTerrain.Destructible;
using DestructibleTerrain.Triangulation;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public static class DTUtility
{
    public const int FixedPointConversion = 10000000;

    public class ApproximateVector2Comparer : IEqualityComparer<Vector2>
    {
        public bool Equals(Vector2 a, Vector2 b) {
            return a.Approximately(b);
        }

        public int GetHashCode(Vector2 v) {
            int x = v.x.ToFixedPoint();
            int y = v.y.ToFixedPoint();

            return ListHashCode(new int[] { x, y });
        }
    }

    public static int ListHashCode<T>(IList<T> list) {
        // Multiplicative hash modified from opendatastructures.org chapter 5.3

        long p = (1L << 32) - 5;   // prime: 2^32 - 5
        long z = 0x64b6055aL;  // 32 random bits
        int z2 = 0x5067d19d;   // random odd 32 bit number
        long s = 0;
        long zi = 1;
        for (int i = 0; i < list.Count; i++) {
            // reduce to 31 bits
            long xi = (list[i].GetHashCode() * z2) >> 1;
            s = (s + zi * xi) % p;
            zi = (zi * z) % p;
        }
        s = (s + zi * (p - 1)) % p;
        return (int)s;
    }

    public static int ToFixedPoint(this float n) {
        return (int)Mathf.Round(n * FixedPointConversion);
    }

    public static float FromFixedPoint(this int n) {
        return n / (float)FixedPointConversion;
    }

    public static bool Approximately(this Vector2 a, Vector2 b) {
        return a.x.ToFixedPoint() == b.x.ToFixedPoint() && a.y.ToFixedPoint() == b.y.ToFixedPoint();
    }

    public static int FixedPointHashCode(this Vector2 v) {
        int x = v.x.ToFixedPoint();
        int y = v.y.ToFixedPoint();

        return ListHashCode(new int[] { x, y });
    }

    public static bool ContainSameValues<T> (IEnumerable<T> inA, IEnumerable<T> inB) where T : IEquatable<T> {
        if (inA.Count() != inB.Count()) {
            return false;
        }
        List<T> a = new List<T>(inA);
        List<T> b = new List<T>(inB);
        for (int i = 0; i < a.Count; ++i) {
            for (int j = 0; j < b.Count; ++j) {
                if (a[i].Equals(b[j])) {
                    a.RemoveAt(i--);
                    b.RemoveAt(j--);
                    break;
                }
            }
        }
        return a.Count == 0 && b.Count == 0;
    }

    public static bool PolygroupsEqual (IEnumerable<IEnumerable<DTPolygon>> inA, IEnumerable<IEnumerable<DTPolygon>> inB) {
        if (inA.Count() != inB.Count()) {
            return false;
        }
        List<IEnumerable<DTPolygon>> a = new List<IEnumerable<DTPolygon>>(inA);
        List<IEnumerable<DTPolygon>> b = new List<IEnumerable<DTPolygon>>(inB);
        for (int i = 0; i < a.Count; ++i) {
            for (int j = 0; j < b.Count; ++j) {
                if (ContainSameValues(a[i], b[j])) {
                    a.RemoveAt(i--);
                    b.RemoveAt(j--);
                    break;
                }
            }
        }
        return a.Count == 0 && b.Count == 0;
    }

    public static T GetCircular<T>(this IList<T> list, int i) {
        if (list.Count == 0) {
            throw new IndexOutOfRangeException("Cannot get circular index of empty list.");
        }
        i = ((i % list.Count) + list.Count) % list.Count;
        return list[i];
    }

    // Removes unnecessary vertices
    public static List<Vector2> SimplifyContour(List<Vector2> inContour) {
        if (inContour.Count < 3) {
            return null;
        }

        List<Vector2> contour = new List<Vector2>(inContour);

        for (int i = 0; i < contour.Count; ++i) {
            Vector2 fromPrev = contour.GetCircular(i) - contour.GetCircular(i - 1);
            Vector2 toNext = contour.GetCircular(i + 1) - contour.GetCircular(i);
            if (fromPrev.Cross(toNext) == 0) {
                contour.RemoveAt((i % contour.Count + contour.Count) % contour.Count);
                if (contour.Count < 3) {
                    return null;
                }
                i -= 2;
            }
        }

        return contour;
    }

    public static void SetCW(this List<Vector2> contour) {
        if (contour.Count < 3) {
            return;
        }

        Vector2 v0 = contour[1] - contour[0];
        Vector2 v1 = contour[2] - contour[1];
        if (v0.Cross(v1) > 0) {
            contour.Reverse();
        }
    }

    public static void SetCCW(this List<Vector2> contour) {
        if (contour.Count < 3) {
            return;
        }

        Vector2 v0 = contour[1] - contour[0];
        Vector2 v1 = contour[2] - contour[1];
        if (v0.Cross(v1) < 0) {
            contour.Reverse();
        }
    }

    public static DTPolygon IdentifyHoles(this DTPolygon inPoly) {
        DTProfilerMarkers.IdentifyHoles.Begin();

        List<Vector2> workingContour = new List<Vector2>(inPoly.Contour);
        List<List<Vector2>> loops = new List<List<Vector2>>();

        // Repeat until all loops are found
        while (workingContour.Count > 0) {
            // Simplify contour to remove edges that overlap the previous edge
            workingContour = SimplifyContour(workingContour);
            if (workingContour == null) {
                break;
            }
            Dictionary<Vector2, int> vertices = new Dictionary<Vector2, int>(new ApproximateVector2Comparer());
            for (int i = 0; i < workingContour.Count; ++i) {
                Vector2 v = workingContour[i];

                // If this is a repeated vertex, we've found a loop
                if (vertices.ContainsKey(v)) {
                    // Separate this loop from the working contour
                    int start = vertices[v];
                    int count = i - start;
                    loops.Add(workingContour.GetRange(start, count));
                    workingContour.RemoveRange(start, count);
                    vertices[v] = i;
                    // Stop so that we can simplify the polygon and start from the beginning to find the next loop
                    break;
                }

                vertices[v] = i;

                // Add the final remaining loop
                if (vertices.Count == workingContour.Count) {
                    if (loops.Count == 0) {
                        // If there were no other loops, then the contour does not contain unidentified holes
                        DTProfilerMarkers.IdentifyHoles.End();
                        return inPoly;
                    }

                    loops.Add(workingContour);
                    workingContour = new List<Vector2>();
                }
            }
        }

        // Start with holes already in the original polygon
        DTPolygon outPoly = new DTPolygon();
        foreach (var hole in inPoly.Holes) {
            outPoly.Holes.Add(hole);
        }

        // We now have a list of loops. Check which ones are inside the others, and mark those as holes as well.
        for (int i = 0; i < loops.Count; ++i) {
            if (loops[i] == null) {
                continue;
            }
            for (int j = i + 1; j < loops.Count; ++j) {
                if (loops[j] == null) {
                    continue;
                }
                if (QuickPolyInPoly(loops[i], loops[j])) {
                    loops[i].SetCW();
                    outPoly.Holes.Add(loops[i]);
                    loops[i] = null;
                    break;
                } else if (QuickPolyInPoly(loops[j], loops[i])) {
                    loops[j].SetCW();
                    outPoly.Holes.Add(loops[j]);
                    loops[j] = null;
                    break;
                }
            }
        }

        // Join any remaining loops and make the result the contour of the new polygon
        for (int i = 1; i < loops.Count; ++i) {
            if (loops[i] != null) {
                loops[i].SetCCW();
                outPoly.Contour = JoinContours(outPoly.Contour, loops[i]);
            }
        }

        DTProfilerMarkers.IdentifyHoles.End();
        return outPoly;
    }

    // Adapted from code in clipper.cs from Clipper library http://www.angusj.com/delphi/clipper.php
    // See "The Point in Polygon Problem for Arbitrary Polygons" by Hormann & Agathos
    // http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf
    // Returns 0 if false, +1 if true, -1 if pt ON polygon boundary
    public static int PointInPolygon(Vector2 pt, List<Vector2> contour) {
        int result = 0;
        float ptx = pt.x, pty = pt.y;
        float poly0x = contour[0].x, poly0y = contour[0].y;
        for (int i = 0; i < contour.Count; ++i) {
            float poly1x = contour[i].x, poly1y =contour[i].y;

            if (poly1y == pty) {
                if ((poly1x == ptx) || (poly0y == pty &&
                  ((poly1x > ptx) == (poly0x < ptx)))) return -1;
            }
            if ((poly0y < pty) != (poly1y < pty)) {
                if (poly0x >= ptx) {
                    if (poly1x > ptx) result = 1 - result;
                    else {
                        float d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);
                        if (d == 0) return -1;
                        if ((d > 0) == (poly1y > poly0y)) result = 1 - result;
                    }
                } else {
                    if (poly1x > ptx) {
                        float d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);
                        if (d == 0) return -1;
                        if ((d > 0) == (poly1y > poly0y)) result = 1 - result;
                    }
                }
            }
            poly0x = poly1x; poly0y = poly1y;
        }
        return result;
    }

    // Checks points in the inner contour to see if they are on the interior of the outer contour.
    // Only checks until it finds a point that is not exactly on the boundary.
    // This is not thorough and assumes that edges do not otherwise intersect except when the vertex from one
    // contour lies on the boundary of the other.
    // Returns true if inner is within outer, false otherwise.
    public static bool QuickPolyInPoly(List<Vector2> inner, List<Vector2> outer) {
        foreach (Vector2 innerPoint in inner) {
            int result = PointInPolygon(innerPoint, outer);
            if (result >= 0) {
                return result != 0;
            }
        }
        return true;
    }

    public static List<Vector2> JoinContours(List<Vector2> a, List<Vector2> b) {
        if (a.Count == 0) {
            var output = new List<Vector2>(b);
            return output;
        }
        if (b.Count == 0) {
            var output = new List<Vector2>(a);
            return output;
        }
        
        // Add all of a's vertices to a map
        Dictionary<Vector2, int> aVertices = new Dictionary<Vector2, int>(new ApproximateVector2Comparer());
        for (int i = 0; i < a.Count; ++i) {
            aVertices.Add(a[i], i);
        }

        // Check b for vertices shared with a
        for (int bIndex = 0; bIndex < b.Count; ++bIndex) {
            Vector2 v = b[bIndex];
            
            if (aVertices.ContainsKey(v)) {
                int aIndex = aVertices[v];

                List<Vector2> output = new List<Vector2>();
                // Add a up to and including shared point
                output.AddRange(a.GetRange(0, aIndex + 1));
                // Add b after shared point
                if (bIndex < b.Count - 1) {
                    output.AddRange(b.GetRange(bIndex + 1, b.Count - bIndex - 1));
                }
                // Add b up to and including shared point
                output.AddRange(b.GetRange(0, bIndex + 1));
                // Add a after shared point
                if (aIndex < a.Count - 1) {
                    output.AddRange(a.GetRange(aIndex + 1, a.Count - aIndex - 1));
                }
                return output;
            }
        }

        return null;
    }

    // Removes unnecessary vertices
    public static DTPolygon Simplify(this DTPolygon inPoly) {
        DTProfilerMarkers.SimplifyPolygon.Begin();

        if (inPoly.Contour.Count == 0) {
            DTProfilerMarkers.SimplifyPolygon.End();
            return null;
        }
        var simplifiedContour = SimplifyContour(inPoly.Contour);
        if (simplifiedContour == null) {
            DTProfilerMarkers.SimplifyPolygon.End();
            return null;
        }

        List<List<Vector2>> simplifiedHoles = new List<List<Vector2>>();
        foreach (var hole in inPoly.Holes) {
            var simplifiedHole = SimplifyContour(hole);
            if (simplifiedContour.Count != 0) {
                simplifiedHoles.Add(simplifiedHole);
            }
        }

        DTPolygon simplifiedPolygon = new DTPolygon(simplifiedContour, simplifiedHoles);
        DTProfilerMarkers.SimplifyPolygon.End();
        return simplifiedPolygon;
    }

    public static float Dot(this Vector2 a, Vector2 b) {
        return Vector2.Dot(a, b);
    }

    public static float Cross(this Vector2 a, Vector2 b) {
        return (a.x * b.y) - (a.y * b.x);
    }

    // -1 means the object bounds are completely outside the explosion.
    // 0 means the bounds intersect.
    // 1 means the object bounds are completely inside the explosion.
    public static int BoundsCheck(DestructibleObject dtObj, Explosion exp) {
        Bounds oBounds = dtObj.GetComponent<Collider2D>().bounds;
        Vector3 ePos = new Vector3(exp.Position.x, exp.Position.y);
        float radSq = exp.Radius * exp.Radius;

        // Completely outside
        if ((oBounds.ClosestPoint(ePos) - ePos).sqrMagnitude >= radSq) {
            return -1;
        }

        // Compute furthest point
        Vector3 furthestPoint = new Vector3(oBounds.min.x, oBounds.min.y, 0);
        if (oBounds.center.x > ePos.x) {
            furthestPoint.x = oBounds.max.x;
        }
        if (oBounds.center.y > ePos.y) {
            furthestPoint.y = oBounds.max.y;
        }

        // Completely inside
        if ((furthestPoint - ePos).sqrMagnitude <= radSq) {
            return 1;
        }

        // Bounds intersect
        return 0;
    }
    
    // Returns true if bounds overlap
    public static bool BoundsCheck(DTPolygon a, DTPolygon b) {
        Vector2 aMin = a.Contour[0];
        Vector2 aMax = a.Contour[0];
        foreach (Vector2 v in a.Contour) {
            if (v.x < aMin.x) {
                aMin.x = v.x;
            }
            if (v.y < aMin.y) {
                aMin.y = v.y;
            }
            if (v.x > aMax.x) {
                aMax.x = v.x;
            }
            if (v.y > aMax.y) {
                aMax.y = v.y;
            }
        }

        Vector2 bMin = b.Contour[0];
        Vector2 bMax = b.Contour[0];
        foreach (Vector2 v in b.Contour) {
            if (v.x < bMin.x) {
                bMin.x = v.x;
            }
            if (v.y < bMin.y) {
                bMin.y = v.y;
            }
            if (v.x > bMax.x) {
                bMax.x = v.x;
            }
            if (v.y > bMax.y) {
                bMax.y = v.y;
            }
        }

        return bMax.x > aMin.x && bMax.y > aMin.y && aMax.x > bMin.x && aMax.y > bMin.y;
    }

    public static Bounds GetBounds(IEnumerable<Vector2> points) {
        Vector2 min = points.First();
        Vector2 max = points.First();
        foreach (Vector2 p in points) {
            if (p.x < min.x) {
                min.x = p.x;
            }
            if (p.x > max.x) {
                max.x = p.x;
            }
            if (p.y < min.y) {
                min.y = p.y;
            }
            if (p.y > max.y) {
                max.y = p.y;
            }
        }
        Bounds b = new Bounds();
        b.SetMinMax(min, max);
        return b;
    }

    public static DTConvexPolygroup TriangulateAll(List<DTPolygon> polygonList, ITriangulator triangulator) {
        var triangleList = new List<List<Vector2>>(); 
        foreach (var poly in polygonList) {
            triangleList.AddRange(triangulator.PolygonToTriangleList(poly));
        }
        return new DTConvexPolygroup(triangleList);
    }

    public static DTConvexPolygroup ToPolygroup(this DTMesh mesh) {
        DTProfilerMarkers.MeshToPolygroup.Begin();
        DTConvexPolygroup polygroup = new DTConvexPolygroup(
            mesh.Partitions.Select(part => part.Select(i => mesh.Vertices[i]).ToList()).ToList());
        DTProfilerMarkers.MeshToPolygroup.End();
        return polygroup;
    }
    
    public static DTMesh ToMesh(this DTConvexPolygroup polygroup) {
        DTProfilerMarkers.PolygroupToMesh.Begin();

        // List of unique vertices for the mesh
        List<Vector2> vertices = new List<Vector2>();

        // Maps each vertex to its index in the vertices list
        Dictionary<Vector2, int> vertexMap = new Dictionary<Vector2, int>(new ApproximateVector2Comparer());

        // List of partitions, each of which is a list of vertex indices
        List<List<int>> partitions = new List<List<int>>(polygroup.Count);

        foreach (var poly in polygroup) {
            // Indices of the vertices in this partition
            List<int> indices = new List<int>();
            foreach (var v in poly) {
                // Get the mapped index of the vertex. If the vertex is not yet mapped, map it to the index at the end
                // of the vertices list
                if (!vertexMap.TryGetValue(v, out int index)) {
                    index = vertices.Count;
                    vertexMap.Add(v, index);
                    vertices.Add(v);
                }
                indices.Add(index);
            }
            partitions.Add(indices);
        }

        DTMesh mesh = new DTMesh(vertices, partitions);
        DTProfilerMarkers.PolygroupToMesh.End();
        return mesh;
    }
    
    // Destroys all GameObjects.
    // This should be called at the end of tests.
    public static void CleanUpGameObjects() {
        GameObject[] gos = UnityEngine.Object.FindObjectsOfType<GameObject>();
        foreach (GameObject go in gos) {
            UnityEngine.Object.Destroy(go);
        }
    }
}
